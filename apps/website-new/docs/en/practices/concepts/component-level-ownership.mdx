import {Tabs,Tab} from '@theme';

# Component Level Ownership


## Introduction to Component Level Ownership

What is Component Level Ownership (CLO)?

It's a pattern of software design that shifts as much responsibility to the component as possible. We have heard of dumb components before… well these are smart components

The idea behind them is they work standalone or near standalone. Inside of a monolithic app, you'll probably find a lot of logic colocated at the page level. Data, state, props, that are sent down to dumb components. In a smart component, the page would send hints about what the component should do. In theory, I should be able to mount any component on a CRA app, pass it some very basic props/hints, and it'll do the rest of the job.

## Implementing Component Level Ownership

To achieve Component Level Ownership, each application needs to configure its Webpack Module Federation plugin with two options: `name` and `exposes`. The `name` option defines the unique identifier of the application, which will be used by other applications to reference it. The `exposes` option defines a mapping of keys to local files that contain the components to be exposed. For example:
<Tabs>
  <Tab label={"React"}>

    ### Create a Self-sustaining component
    The core concept of "Component Level Ownership" is to provide modules that are self sufficent, intepdent when possible.
    The host can pass props that tell it what to do, but its best when the component constols its own data supply and contracts.

    ```jsx title="src/ServiceComponent.jsx"
    import React, { Suspense } from 'react';

    function fetchData(url) {
      let status = 'pending';
      let result;
      let suspender = fetch(url)
        .then((response) => response.json())
        .then((data) => {
          status = 'success';
          result = data;
        }, (error) => {
          status = 'error';
          result = error;
        });

      return {
        read() {
          if (status === 'pending') {
            throw suspender;
          } else if (status === 'error') {
            throw result;
          } else if (status === 'success') {
            return result;
          }
        }
      };
    }

    const resource = fetchData('https://jsonplaceholder.typicode.com/todos/1');

    function HelloWorld() {
      const data = resource.read(); // This will suspend if the data isn't ready
      return <pre>{JSON.stringify(data)}</pre>;
    }

    export default function Wrapper() {
      return (
        <Suspense fallback={<pre>Loading...</pre>}>
          <HelloWorld />
        </Suspense>
      );
    }

    ```

    ### Expose the component

    Expose the component through your plugin configuration. The method for doing this may differ depending on the tool you are using. For example, with [rsbuild](https://rsbuild.dev/config/module-federation/options), you would configure the `exposes` option. With [rspack](https://www.rspack.dev/plugins/webpack/module-federation-plugin.html), you would use the `exposes` property. And with [webpack](https://www.npmjs.com/package/@module-federation/enhanced), you would use the `exposes` option in the `ModuleFederationPlugin` configuration.

    ```javascript title="rspack.config.js"
    new ModuleFederationPlugin({
      name: 'remote',
      exposes: {
        './ServiceComponent': './src/ServiceComponent',
      },
      filename: 'remoteEntry.js',
      shared: {
        react: {
          singleton: true,
          requiredVersion: dependencies['react'],
        },
        'react-dom': {
          singleton: true,
          requiredVersion: dependencies['react-dom'],
        },
      },
    });
    ```
    ### Import it in the host

    The component should require a minimal api contract with the host since it is able to fetch it own data
    
    ```jsx title="app.jsx"
    import React from 'react';

    const RemoteButton = React.lazy(() => import('remote/Button'));
    const ServiceComponent = React.lazy(() => import('remote/ServiceComponent'));

    const App = () => (
      <div>
        <h1>Basic Host-Remote</h1>
        <h2>Host</h2>
        <React.Suspense fallback="Loading Button">
          <RemoteButton />
          <ServiceComponent/>
        </React.Suspense>
      </div>
    );

    export default App;
    ```
  </Tab>
  <Tab label={"Angular"}>
    ```javascript
    new ModuleFederationPlugin({
      name: "app1",
      exposes: {
        "./Heroes": "./src/app/heroes/heroes.component.ts",
        "./Villains": "./src/app/villains/villains.component.ts",
      },
    });
    ```

    This configuration tells Webpack that `app1` exposes two components: `Heroes` and `Villains`, which are located in the specified files. These components can be imported by other applications using the syntax `app1/ComponentName`, where `app1` is the name of the application and `ComponentName` is the key of the component in the `exposes` option.

    For example, another application called `app2` can import and use the `Heroes` component from `app1` like this:

    ```javascript
    import { Heroes } from "app1/Heroes";

    // use Heroes component in app2
    ```

    To make this work, `app2` also needs to configure its Webpack module federation plugin with two options: `remotes` and `shared`. The `remotes` option defines a mapping of names to URLs that point to the remote entry files of other applications. The remote entry file is a special file generated by Webpack that contains information about the exposed modules and how to load them. The `shared` option defines which modules are shared between the applications, such as vendor libraries or common dependencies.

    For example:

    ```javascript
    new ModuleFederationPlugin({
      remotes: {
        app1: "app1@http://localhost:3000/remoteEntry.js",
      },
      shared: ["@angular/core", "@angular/common", "@angular/router"],
    });
    ```

    This configuration tells Webpack that `app2` can import modules from `app1`, which has a remote entry file at the specified URL. It also tells Webpack that both applications share some Angular modules, so they don't need to load them twice.

    ## Benefits of Component Level Ownership

    1. **Improved Scalability**: As your application grows, Component Level Ownership allows you to maintain a modular architecture, preventing tightly-coupled dependencies and reducing complexity by breaking down an application into smaller components, so you can better allocate resources and scale your application as needed.

    2. **Maintainability**: By encapsulating the logic and dependencies of each component, you can improve code readability and maintainability, making it easier to update and refactor components as needed. Additionally, assigning ownership to individual components simplifies the process of maintaining and updating the codebase too, as it is clear who is responsible for each component.

    3. **Team Collaboration**: Component Level Ownership enables better collaboration between teams by allowing them to work independently on their respective components, streamlining the development process and reducing the risk of conflicts.

    4. **Performance**: With dynamic imports and lazy loading, you can optimize your application's performance by only loading the required components and their dependencies as needed.

    ## What are the challenges of Component Level Ownership?

    Component Level Ownership also comes with some challenges that need to be addressed:

    - It requires careful design and documentation of the exposed components, as they need to have a clear interface and contract with other applications.
    - It introduces some complexity and overhead in the configuration and orchestration of the applications, as they need to know where and how to find and load each other's components.
    - It may cause some compatibility issues or conflicts between different versions or implementations of the same component, especially if they are not properly isolated or scoped.

    ## How can we overcome these challenges?

    There are some best practices and tools that can help us overcome these challenges and leverage Component Level Ownership effectively:

    - Use standalone components that have minimal dependencies and side effects, and follow a single responsibility principle. This will make them easier to expose
    - Use SCAM (Single Component Angular Module) pattern for shared components, which means creating a dedicated NgModule for each component that declares and exports it. This will make them easier to import and reuse by other applications.
    - Use Dynamic Module Federation to load remote components on demand, instead of statically importing them. This will reduce the initial bundle size and improve performance.
    - Use Angular's built-in mechanisms to isolate and scope component styles, such as ViewEncapsulation and :host selector. This will prevent style conflicts and leakage between components.
    - Use Angular's dependency injection system to provide services and configuration to components, instead of relying on global variables or constants. This will make them more testable and adaptable to different environments³.
    - Use custom elements or web components to wrap standalone components and expose them as standard HTML elements. This will make them interoperable with other frameworks or vanilla JavaScript.
  </Tab>
</Tabs>


